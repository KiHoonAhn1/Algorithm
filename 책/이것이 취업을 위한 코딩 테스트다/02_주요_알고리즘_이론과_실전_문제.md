# 알고리즘 이론과 실전 문제



## 1. 그리디

> 현재 상황에서 지금 당장 좋은 것만 고르는 방법
>
> 탐욕법

* **최단 경로**를 찾는 문제는 플로이드 워셜 혹은 다익스트라 알고리즘으로 풀 수 있는데, '다익스트라' 알고리즘은 엄밀히 말하면 그리디 알고리즘이므로, 암기가 필요하다.
* 기준에 따라 좋은 것을 선택하는 알고리즘이므로, 정렬 알고리즘과 주로 짝을 이뤄 출제된다. 



* 대부분의 그리디 알고리즘 문제에서는 이처럼 문제 풀이를 위한 최소한의 아이디어를 떠올리고 이것이 정당한지 검토할 수 있어야 답을 도출할 수 있다.
* 어떤 코딩 테스트 문제를 만났을 때, **바로 문제 유형을 파악하기 어렵다면** 그리디 알고리즘을 의심하고, 문제를 해결할 수 있는 탐욕적인 해결법이 존재하는지 고민해보자.

### 실전 문제

| 문제명       | 링크                 | 기출                           |
| ------------ | -------------------- | ------------------------------ |
| 큰 수의 법칙 | [링크](./ch03_01.py) | 2019 국가 교육기관 코딩 테스트 |
|              |                      |                                |
|              |                      |                                |

### 01_큰 수의 법칙

```python
# N, M, K를 공백으로 구분하여 입력받기
n, m, k = map(int, input().split())
# N개의 수를 공백으로 구분하여 입력받기
data = list(map(int, input().split()))

data.sort() # 입력받은 수들 정렬하기
first = data[n - 1] # 가장 큰 수
second = data[n - 2] # 두 번째로 큰 수

result = 0

while True:
    for i in range(k): # 가장 큰 수를 K번 더하기
        if m == 0: # m이 0이라면 반복문 탈출
            break
        result += first
        m -= 1 # 더할 때마다 1씩 빼기
    if m == 0: # m이 0이라면 반복문 탈출
        break
    result += second # 두 번째로 큰 수를 한 번 더하기
    m -= 1 # 더할 때마다 1씩 빼기

print(result) # 최종 답안 출력
```

* M이 매우 크다면 시간 초과 문제가 생길 수 있으므로 규칙을 이용하자

```python
# N, M, K를 공백으로 구분하여 입력받기
n, m, k = map(int, input().split())
# N개의 수를 공백으로 구분하여 입력받기
data = list(map(int, input().split()))

data.sort() # 입력받은 수를 정렬하기
first = data[-1] # 가장 큰 수
second = data[-2] # 두 번째로 큰 수

# 가장 큰 수가 더해지는 횟수 계산
count = int(m / (k + 1)) * k
count += m % (k+1)
result = 0
result += count * first # 가장 큰 수 더하기
result += (m - count) * second # 두 번째로 큰 수 더하기

print(result)
```



### 02_숫자 카드 게임



